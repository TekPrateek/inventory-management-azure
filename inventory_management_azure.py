# -*- coding: utf-8 -*-
"""Inventory-Management-Azure.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15hfFPwKymGmNsf2JZyTxgPo8GbLZ2wPy
"""

pip install azure.cosmos

pip install azure.storage.blob

#Import Important Libraries
import pandas as pd
from azure.cosmos import exceptions, CosmosClient
from azure.storage.blob import BlobServiceClient
import io
from azure.cosmos.partition_key import PartitionKey

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px


import warnings
warnings.filterwarnings("ignore")

#Load the dataset
df=pd.read_csv("/content/drive/MyDrive/Colab Notebooks/TIP /BigBasket Products.csv")
df.head()

df.info()

df.shape

#Rename Index to id for Cosmos DB
df.rename(columns = {'index':'id'}, inplace = True)
df.info()

#Change id type to String for Cosmos Db
df1['id'] = df1['id'].astype(str)

print('category values')
df.category.value_counts()

print('subcategory values')
df.sub_category.value_counts()

df.isnull().sum()

#Mean of ratings
print('Mean Value')
rating_mean = df.rating.mean()
rating_mean

#Median of ratings
print('Median Value')
rating_median = df.rating.median()
rating_median

#filling the rating null values by mean rating
df.rating.fillna(value=rating_mean,inplace=True)

#Drop Rows with Missing Values
df.dropna(inplace=True)

df.isnull().sum()

#Connect Azure Blob Storage and create a new container
blob_connection_string = 'DefaultEndpointsProtocol=https;AccountName=inven;AccountKey=uxM4LqtpG4MZ+aUCeolmGsiWXgW2bD71Y1CeYW5a/HZkc+2rF2zotVq0xCYRTIxFkz5eH32/TxEv+ASt1GU15w==;EndpointSuffix=core.windows.net'
blob_service_client = BlobServiceClient.from_connection_string(blob_connection_string)
container_client = blob_service_client.get_container_client('inventory')

#Transfer the dataset into the Container
container_client.create_container()
blob_client = container_client.get_blob_client('inventory_data.csv')
blob_client.upload_blob(data=df.to_csv(index=False), overwrite=True)

#Load the Dataset from the Blob Storage
blob_data = blob_client.download_blob()
blob_data_text = blob_data.content_as_text()
df1 = pd.read_csv(io.StringIO(blob_data_text))

df1.head(5)

#Check No.of Unique items in each row
print(f'Number of Brands is',df1["brand"].nunique())
print(f'Number of Categories is',df1["category"].nunique())
print(f'Number of Sub-Categories is',df1["sub_category"].nunique())
print(f'Number of Products is', df1["product"].nunique())
print(f'Number of Types is', df1["type"].nunique())

#Plot a Graph to check the range of major ratings
sns.histplot(df1.rating,kde=True)

#Create a new row called discount
df1["discount"] = (df1["market_price"] - df1["sale_price"]) / df1["market_price"] * 100
df1.tail()

discount_data = df1[df1['discount'] == True]
discount_data

#Plot the Graph whcih shows the difference between actual price and the discounted price
fig = plt.figure(figsize=(20,10))

sns.kdeplot(discount_data['rating'], shade=True, label='Discounted Products')
sns.kdeplot(df1['rating'], shade=True, label='All Products')

plt.xlabel("Ratings", fontsize=15, weight='semibold')
plt.ylabel("Density", fontsize=15, weight='semibold')
plt.title("Relative distribution of all products with discounted products", fontsize=15, weight='semibold')

handles, labels = plt.gca().get_legend_handles_labels()
plt.legend(handles, labels, fontsize=12)

#Plot a Pairplot based on rating
sns.pairplot(df1,vars=['rating','sale_price','market_price'],hue='rating')

# printing top subcategories with 5.0 rating for each category
category_list = df1['category'].value_counts().index.tolist()
fig, axes = plt.subplots(3, 3, figsize=(25,20))
for i in range(9):
    order = df1['sub_category'].loc[df1['category'] == category_list[i]].value_counts().index
    sns.countplot(ax=axes[i//3][i%3], x='sub_category', data=df.loc[df1['category'] == category_list[i]], palette='GnBu', order=order)
    fig.subplots_adjust(hspace=.8)
    axes[i//3][i%3].set_title(f'Top sub-categories of {category_list[i]}: Rating 5.0')
    axes[i//3][i%3].set_xticklabels(order.tolist(), rotation = 45)

#Connect Azure Cosmos Db
cosmos_endpoint = 'https://inven.documents.azure.com:443/'
cosmos_key = 'AOc9Bzg8cwg9b3XEFKjX9OWmdX6Pu2EfrosjnD50s0GWyXHkJaeZWKDaxV7vkybpL9tOs4pTqKbFACDbg7eabw=='
cosmos_client = CosmosClient(cosmos_endpoint, cosmos_key)

#Create a new Database and a new Container
database_name = 'InventoryDB1'
container_name = 'InventoryContainer'
database = cosmos_client.create_database_if_not_exists(database_name)
container = database.create_container_if_not_exists(
    id=container_name,
    partition_key='/product',
    offer_throughput=400
)

df1.head(1).to_dict

#Insert the Loaded data into the Cosmos Db container
for _, row in df1.iterrows():
    container.create_item(row.to_dict())

#Print Products with 4.0> rating using Cosmos Db
query = "SELECT * FROM c WHERE c.rating >= 4.0"
cosmos_results = list(container.query_items(query, enable_cross_partition_query=True))

cosmos_results

#Key Filtering Using Cosmos Db
search_keyword = input('Enter your text : ')
filtered_blob_df = df1[df1['product'].str.contains(search_keyword, case=False)]

database = cosmos_client.get_database_client(database_name)
container = database.get_container_client(container_name)
query = f"SELECT * FROM c WHERE CONTAINS(c.product, '{search_keyword}')"
filtered_cosmos_results = list(container.query_items(query, enable_cross_partition_query=True))
filtered_cosmos_results

#Import ML libraries
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# Key Filtering 1 Using ML Models
vectorizer = TfidfVectorizer(stop_words='english')
tfidf_matrix = vectorizer.fit_transform(df1['description'].values.astype('U'))

def recommend_product(input_text):
    input_vector = vectorizer.transform([input_text])
    similarities = cosine_similarity(input_vector, tfidf_matrix)
    most_similar_index = similarities.argmax()
    most_similar_product = df.iloc[most_similar_index]
    return most_similar_product

user_input = input("Enter your text: ")
recommended_product = recommend_product(user_input)
print("Recommended Product:")
print("Name:", recommended_product['product'])
print("Brand:", recommended_product['brand'])
print("Category:", recommended_product['category'])

#Key Filtering 2 Using ML Models
def recommend_products(input_text, num_recommendations=5):

    input_vector = vectorizer.transform([input_text])
    similarities = cosine_similarity(input_vector, tfidf_matrix)
    top_indices = similarities.argsort()[0][-num_recommendations:][::-1]
    top_products = df.iloc[top_indices]
    return top_products

user_input = input("Enter your text: ")
recommended_products = recommend_products(user_input)
print("Recommended Products:")
for index, product in recommended_products.iterrows():
    print("Name:", product['product'])
    print("Brand:", product['brand'])
    print("Category:", product['category'])
    print("-----------------------------")

#Demand Forecasting
from sklearn.linear_model import LinearRegression
X = df1[['rating']]
y = df1['sale_price']

model = LinearRegression()
model.fit(X, y)

results_df = pd.DataFrame({
    'Rating': X['rating'],
    'Actual Sale Price': y,
    'Predicted Sale Price': model.predict(X)
})

print("Demand Forecasting Results:")
print(results_df)

plt.scatter(X, y, color='blue', label='Actual Data')
plt.plot(X, model.predict(X), color='red', label='Demand Forecast')
plt.xlabel('Rating')
plt.ylabel('Sale Price')
plt.title('Demand Forecasting')
plt.legend()
plt.show()